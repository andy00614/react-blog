[{"articleId":"2019-10-23-tsconfig.json入门指南","content":"\n**只是一种规范**\n\n## Master\n\nproduction-ready,master上不能进行任何commit\n\n## Develop\n\n相当于整合feature分支，所以develop分支应该会有很多bug。通常也不会在develop上面commit，也是通过feature merge上来\n\n## Feature\n\n如果有两个人A/B 去开发一个功能,那么这两个人会从develop分支分出来，合并到develop上\n\n## Release\n\n当develop认为是稳定版本的时候，会拉出release做一个bug-bash之类的，最后再合进master和develop\n\n## Hotfix\n\n当master出现问题的时候拉hotfix，修补好后再合进master\n","time":"2019-10-23","title":"tsconfig.json入门指南"},{"articleId":"2019-02-07-对象、原型、原型链","content":"\n# 良好的面向对象系统设计是使应用健壮、可维护性的关键\n\n# JS的面向对象\n\n是基于原型的而不是基于类的，但是由于ESNEXT的进步，JS更加接近传统的面向对象语言\n\n# 自检\n\n- 实现new\n- 如何实现集成 es5/es6 继承Date\n- JQuery中的对象思想\n- 类继承是什么、原型继承是什么，他们的区别\n- 面向对象在实战中的场景\n\n# new\n\n## new做了什么\n\neg: const obj = new Foo()\n\n1. 创建了一个对象 obj\n2. 将obj.__proto__ 指向Foo.prototype\n3. 将obj的this指向Foo内的this，并执行函数逻辑\n4. 根据第3步的执行逻辑，返回obj或者你强行在构造函数中return了一个对象\n\n# defineProperty\n\n它描述了数据属性(一些权限和值)和访问器属性(getter/setter)\n\n## 访问器属性\n\n也就是getter,setter，它的作用是，设置一个值，那么其他的值将会改变\n\nvue就是用的访问器属性，在setter的过程中会出发setter,然后再render\n\n### 如果只写getter不写setter会默认为不可写哦\n\n### 示例\n\n    const book = {\n        _year: 2004,\n        edition: 1\n      };\n      Object.defineProperty(book, \"year\", {\n        get() {\n          return this._year;\n        },\n        set(newValue) {\n          if (newValue > this._year) {\n            this.edition = newValue - this._year;\n            this._year = newValue;\n          }\n        }\n      });\n      book.year = 2008;\n      // 浏览器中打开噢\n      console.log(book);\n\n### defineProperties\n\n    let book = {};\n      Object.defineProperties(book, {\n        _year: {\n          writable: true,\n          value: 2004\n        },\n        edition: {\n          writable: true,\n          value: 1\n        },\n        year: {\n          get:function() {\n            return this._year;\n          },\n          set: function(newValue) {\n            if (newValue > this._year) {\n              this.edition = newValue - this._year;\n              this._year = newValue;\n            }\n          }\n        }\n      });\n      book.year = 2008\n      console.log(book);\n\n### 什么时候用?\n\n# 创建对象的模式\n\n## 工厂模式\n\n其实就是通过函数传递几个属性，还可能有一些特定(固定)的属性方法(不通过函数方式传递)，然后生成公共的对象\n\n    {\n      const createPerson = (name, age, job) => {\n        return {\n          name,\n          age,\n          job,\n          sayName() {\n            console.log(this.name);\n          }\n        };\n      };\n      const person = createPerson(\"andy\", 23, \"engineer\");\n      console.log(person);\n      console.log(person instanceof Object); \n      // console.log(person instanceof createPerson); // 会报错\n    }\n\n## 构造函数模式\n\n### 和工厂模式相比\n\n**优点**：\n\na.可以判断出类型\n\nb.不必写return\n\n    {\n      function Person (name, age, job)  {\n        this.name = name;\n        this.age = age;\n        this.job = job;\n        this.sayName = () => {\n          console.log(this.name);\n        };\n      };\n      const person = new Person(\"andy\", 23, \"engineer\")\n      console.log(person)\n      console.log(person instanceof Object)\n      console.log(person instanceof Person)\n    }\n\n构造函数构造出的对象都有一个construcor的属性，来指向它的构造函数，用来表示，instanceof就是判断它的\n\n**缺点**：\n\n每个实例化的sayName方法实际上都不相等，接着上面的代码写:\n\n    const person1 = new Person('andy',25,'a')\n    const person2 = new Person('duruomeng',25,'b')\n    console.log(person1.sayName === person2.sayName) // false\n\n实际上没有必要，**那如何解决？**\n\n在全局放一个sayName的方法\n\n    function Person(name, age, job) {\n      this.name = name;\n      this.age = age;\n      this.job = job;\n      this.sayName = sayName;\n    }\n    \n    function sayName() {\n      alert(this.name);\n    }\n    \n    var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");\n    var person2 = new Person(\"Greg\", 27, \"Doctor\");\n\n缺点：放在全局为这一个函数服务肯定不合适啊，**那如何解决？**\n\n## 原型模式\n\n如下，通过prototype共享了sayName\n\n    {\n      function PersonProto(name, age, job) {\n        this.name = name;\n        this.age = age;\n        this.job = job;\n      }\n      PersonProto.prototype.sayName = function() {\n        console.log(this.name)\n      };\n      const personProto = new PersonProto('andy',25,'eng')\n      console.log('原型模式',personProto);\n      personProto.sayName()\n    }\n\n# 理解原型和原型链\n\n无论什么时候，只要创建了一个新函数，就会为函数创建一个prototype属性,这个属性指向函数的原型对象，这个对象是什么呢，默认会有一个constructor属性，指向这个函数(也是构造函数，**这也正是上面说的实例有一个constructor一样**)\n\n## Object.getPrototypeOf\n\n使用 Object.getPrototypeOf() 可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的\n\n    {\n      function Person(name, age) {\n        this.name = name;\n        this.age = age;\n      }\n      Person.prototype.sayName = function() {\n        console.log(this.name);\n      };\n      const person = new Person(\"andy\", 27);\n      // console.log(person.sayName())\n      // 这样使用\n      console.log(Person.prototype.isPrototypeOf(person));\n      // es5还增加了一个方法，直接获取实例的隐式原型\n      console.log(Object.getPrototypeOf(person))\n    }\n\n## 实例中原型(__**proto**__)的属性不可覆盖\n\n    {\n      function Person() {}\n    \n      Person.prototype.name = \"andy\";\n      Person.prototype.age = 25;\n      Person.prototype.job = \"Software Engineer\";\n      Person.prototype.sayName = function() {\n        console.log(this.name);\n      };\n      \n      const person1 = new Person()\n      const person2 = new Person()\n    \n      person1.age = 30\n    \n      console.log(person1.age); // 30\n      console.log(person2.age); // 25\n    \n    }\n\n## 判断存在是否存在实例对象中还是存在原型中\n\n`Object.hasOwnProperty('name')`\n\n**记住，这是存在于定向的方法，那肯定就是检测对象中是否存在，而不是原型中**\n\n## 实例和原型连接是松散的(通过指针连接)\n\n一个表现特点就是，即使先实例化了一个对象，后再原型中添加方法。我仍然可以通过实例访问到原型的方法，原因是因为\n\n![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b657e20a-b198-45ab-ac11-875c8390e40a/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b657e20a-b198-45ab-ac11-875c8390e40a/Untitled.png)\n\n**总结：**对象和原型的关系就是对象通过Prototype指针连接原型\n\n如果**重写**了Person的原型就不行了\n\n    function Person(){ }\n    \n    var friend = new Person();\n    \n    Person.prototype = {\n    \n    constructor: Person, name : \"Nicholas\", age : 29, job : \"Software Engineer\", sayName : function () { alert(this.name); }\n    \n    };\n    \n    friend.sayName();\n    \n    //error\n\n用图解释上面的现象如下：\n\n![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/68dc4db9-c968-4f46-8f66-ed05588f7302/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/68dc4db9-c968-4f46-8f66-ed05588f7302/Untitled.png)\n\n## 原生对象的原型：\n\n原生的数据结构，比如[],{},'abc'...都是通过Array,Object,String实例化出来的，所以他们享有这些构造函数的原型方法\n\n## 原型模式的缺点：\n\n引用类型的功能耦合性\n\n![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a3f2744-a8e0-41c4-b57b-d81ec4682933/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a3f2744-a8e0-41c4-b57b-d81ec4682933/Untitled.png)\n\n**解决上面的问题，就可以用构造函数模式加原型模式**\n\n属性都用构造函数模式，方法都用原型模式\n\n    function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.friends = [\"Shelby\", \"Court\"]; }\n    \n    Person.prototype = { constructor : Person, sayName : function(){ alert(this.name); } }\n    \n    var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\"); var person2 = new Person(\"Greg\", 27, \"Doctor\");\n    \n    person1.friends.push(\"Van\"); alert(person1.friends); //\"Shelby,Count,Van\" alert(person2.friends); //\"Shelby,Count\" alert(person1.friends === person2.friends); alert(person1.sayName === person2.sayName);\n    \n    //false //true\n\n# 继承\n\noo语言专属\n\n## 接口继承和实现继承\n\n## 如何实现原型继承\n\n常规方法：\n\n    function SuperType() {\n      this.colors = ['red','blue','green']\n    }\n    function SubType() {}\n    \n    SubType.prototype = new SuperType()\n    \n    const instance1 = new SubType()\n    \n    instance1.colors.push('black')\n    \n    console.log(instance1.colors);\n    \n    const instance2 = new SubType()\n     \n    console.log(instance2.colors);\n\n### 有什么问题\n\n1. 如果继承的父类有实例属性且是引用类型，则子类新生成的实例下，该属性不独立\n2. 在创建子类型的实例时，不能向超类型的构造函数中传递参数 暂时每太看懂\n\n    上面这个问题其实就是如下实现，也是class中super的概念\n\n        function SuperType(name){ this.name = name; }\n        \n        function SubType(){\n        \n        //继承了 SuperType，同时还传递了参数 SuperType.call(this, \"Nicholas\");\n        \n        //实例属性 this.age = 29;\n        \n        }\n        \n        var instance = new SubType(); alert(instance.name); //\"Nicholas\"; alert(instance.age); //29\n\n## 如何实现继承(解决上面问题)\n\n## 1.借用构造函数方式\n\n    {\n      function SuperType() {\n        this.colors = [\"red\", \"blue\", \"green\"];\n      }\n      function SubType() {\n        SuperType.call(this)\n      }\n      const instance1 = new SubType()\n      instance1.colors.push('black');\n      console.log(instance1.colors);\n      const instance2 = new SubType()\n      console.log(instance2.colors)\n    }\n","time":"2019-02-07","title":"对象、原型、原型链"},{"articleId":"2019-02-07-ssr","content":"\n# 服务端渲染 vs 客户端渲染\n\n## 什么是服务端渲染？\n\n就是将html通过服务器返回了，页面的产生又服务器决定。它的特性是从鼠标右键看网页源代码，和spa是不一样的\n\n![1.png](https://i.loli.net/2020/04/21/lDe8UiTmh6HIbco.png)\n\n![2.png](https://i.loli.net/2020/04/21/VOFx476e9Cbdzik.png)\n\n## 什么是客户端渲染(传统的React之类)\n\n就是将bundle.js返回到客户端，然后通过从客户端加载js文件的方式来进行渲染，可以做一个测试，就是将浏览器设置中禁用JavaScript，网页就打不开了,所以网页完全由js渲染\n\n## 他俩的优缺点：\n\n### csr优点：\n\n前后端分离架构，开发效率高\n\n![3.png](https://i.loli.net/2020/04/21/o1TMFuWHqklUX9d.png)\n\n### csr缺点：\n\n![4.png](https://i.loli.net/2020/04/21/Y7vwIiPGjd6BE3T.png)\n\n1. csr看到页面内容的时间以来于整个js，所以首屏加载时间慢\n2. seo不行，因为他只认识html上的文本内容，不认识js里面的\n\n## ssr的缺点：\n\ncsr消耗的是客户端的性能，而ssr消耗的是服务器的性能，要付出增加服务器的代价\n\n# ssr和csr的渲染区别\n\n![5.png](https://i.loli.net/2020/04/21/VMWv6K3ali4gjt8.png)\n![6.png](https://i.loli.net/2020/04/21/O79EgNAriVPxLbH.png)\n**相当于将React代码从后端运行，将结果通过response返回去**\n\n## 步骤\n\n先创建一个服务器\n\n用express\n\n## 配置webapck\n\n需要告诉打包的是服务器端还是浏览器端的代码\n\n### 配置babel-loader\n\n将js的文件通过babel-loader进行打包\n\n将js的文件通过babel-loader进行打包\n\n![7.png](https://i.loli.net/2020/04/21/DWsxnr9lPO74Tb2.png)\n\n配置webpack的文件如下：\n\n    const path = require('path')\n    module.exports = {\n      target: 'node', // 需要告诉webpack打包的是服务器端还是浏览器端的代码\n      entry: './src/index.js',\n      output: {\n        filename: 'bundle.js',\n        path: path.resolve(__dirname,'build')\n      },\n      module: { // 配置规则\n        rules: [\n          {\n            test: '/\\.js?$/',\n            loader: 'babel-loader',\n            exclude: /node_modules/,\n            options: {\n              presets: [ // 设置编译规则\n                'react', // 这里设置了react，那必须要安装 npm install babel-presets-react --save\n                'stage-0' // 这里应该是更高级的js语法支持, npm install babel-preset-stage-0 --save\n                ['env',{\n                  targets: {\n                    browsers: ['last 2 versions'] // 兼容主流浏览器的最后两个版本\n                  }\n                }]\n              ]\n            }\n          }\n        ]\n      }\n    }\n\n运行webpack: `webpack —config webpack.server.js`\n\n在node环境下，webpack的target光是node不行，还要\n\n![8.png](https://i.loli.net/2020/04/21/EoMRSyvnwrOAKkP.png)\n\n# 服务器端渲染的原理和流程\n\n因为react组件实际上是虚拟dom,因此ReactDom方法能够把虚拟dom转化成字符串形势的dom,通过response来返回\n\n[https://github.com/andy00614/react-ssr/commit/e5ddac546d5f70e8f3e0b7047a545bbbf4718868](https://github.com/andy00614/react-ssr/commit/e5ddac546d5f70e8f3e0b7047a545bbbf4718868)\n\n## 服务器的自动打包和重启(webpack)\n\n![9.png](https://i.loli.net/2020/04/21/2cFveqnRw1azNdM.png)\n\n下一步，怎么监听并**重启呢？**\n\n配置nodemon, 下面commit里面有详细描述\n\n[https://github.com/andy00614/react-ssr/commit/bff3adf7154f5c57961366b7fc7cc10fc57e2a14](https://github.com/andy00614/react-ssr/commit/bff3adf7154f5c57961366b7fc7cc10fc57e2a14)\n\n### npm run all来提升开发效率(对上面再进行优化)\n\n现在的问题是启动了两个窗口，而且浏览器还不会自动刷新(当然这个不一定是缺点)\n\n\n并行的(—parallel)运行dev为开头的所有命令\n\n# 同构\n\n## 什么是同构\n\n\n服务端渲染后click并没有生效，查看源代码，发现button的事件没有渲染出来，\n\n原因是ReactDom的`renderToString`事件是不会被渲染出来的，因此没有事件\n\n\n所以讲React代码再从客户端运行一次，就可以了(第一感觉这个方案有点不好啊)\n\n## 思路\n\n所以通过上面所说，还需要加载js静态文件，那可以用express的static中间件(如果路由是一个静态文件，直接会在public里面拿)\n\n[https://github.com/andy00614/react-ssr/commit/c97552d929a98adf42c3aa94d827918cb9096691](https://github.com/andy00614/react-ssr/commit/c97552d929a98adf42c3aa94d827918cb9096691)\n\n## 同构\n\n将这个文件同构在public的index.js里面\n\n    import React from 'react'\n    import ReactDom from 'react-dom'\n    import Home from '../container/Home'\n    \n    ReactDom.render(<Home />,document.getElementById('root'))\n\n但是public的index.js在浏览器上并不支持esmodule\n\n之后就要配置webpack了。\n\n### 构建client的webpack\n\n用webpack-merge合并webpack配置\n\n[https://github.com/andy00614/react-ssr/commit/56f0e65181117d60c1fd1d58bca774683f06faf8](https://github.com/andy00614/react-ssr/commit/56f0e65181117d60c1fd1d58bca774683f06faf8)\n\n## 同构总的路由\n\n### 客户端路由流程\n\n→broser-router\n\n### 服务器端路由\n\nStaticRouter\n\n- 也属于react-router\n\n    `import {StaticRouter} from 'react-router-dom'`\n\n- 加context\n- 不能感知路径的变化，只能通过req来告诉，所以也要加req\n\n\n## 服务器渲染只发生在第一次进入页面的时候\n\n","time":"2019-02-07","title":"ssr"},{"articleId":"2020-02-01-tsconfig.json入门指南","content":"\n# 前言\n之前开发都是在用脚手架,几乎0配置,只需要会ts的语法就完全可以开发ts项目了，这次自己从零折腾了一个ts项目，发现配置方面还是有挺多坑的，所以不如从头看一下具体的方法和文档，于是总结出了这篇文章。相信我，自己系统的了解一遍和使用脚手架直接配置相比，理解上肯定会有不一样的认知。<br>\n本文主要从简单的方式了解tsconfig.json是干什么的、怎么用、和webpack结合起来会有一些常见的坑以及一些常用的配置，结合文档来看效果更佳 https://www.typescriptlang.org/v2/en/tsconfig<br>\n由于第一次写文章，肯定会有些不严谨或者不好的地方，请大家多多指出建议，谢谢~\n# what\n\n用于编译时遵循的规则表\n\n# why\n\n在没有tsconfig的情况下，我们可以用命令行的方式去执行\n\n`tsc --outFile file.js --target es3 --module commonjs index.ts`\n\n解释上半句：将index.ts用es3的代码和commonjs的形式，编译为file.js在根目录下\n\n1. 需要编译的调调框框很多的情形下(后面将要写一坨)\n2. 团队协作的情形下(大家需要有统一的规范)\n\n# how\n\n## 纯手工命令式\n\n上文有阐述，得自己打一坨\n\n## 配置文件命令式\n\n- 不显式指定 `tsconfig.json` ，此时，编译器会从当前路径开始寻，直到找到tsconfig.json文件为止**和require,import不写具体路径的查找规则差不多**\n- 通过 `--project` （或缩写 `-p` ）指定一个包含 `tsconfig.json` 的路径，和**import,require写个相对路径差不多**\n\n# 配置文件里的具体参数\n\n配置文件里有很多参数，具体场景有的确实还比较抽象，这里统一举例说明\n\n这个`tsconfig.json`大体可以分为两个部分描述，第一部分是编译的规则配置(compilerOptions)，第二个部分是对哪些文件进行编译(files,include,exclude)\n\n最常用的结构代码举例如下:\n\n    {\n        \"compilerOptions\": {},\n        \"files\": [], \n        \"include\": [],\n        \"exclude\": [] \n    }\n\n## compilerOptions\n\n顾名思义就是编译规则,下面会具体说一些常用的详细配置\n\n## files\n\n用法很简单，就是个数组，里面的元素为待编译的ts文件，如下图。\n\nfiles就是根据上面编译规则需要将哪些文件编译,举个例子\n\n\n![Untitled.png](https://user-gold-cdn.xitu.io/2020/2/1/16ffe79d8c9e22df?w=1762&h=862&f=png&s=86316)\n\n上面的配置文件的规则就是将compilerOption的编译规则应用于index.ts下，那如果我下面这样写就肯定会报错了\n\n![2.png](https://user-gold-cdn.xitu.io/2020/2/1/16ffe7b9f3e698ac?w=2476&h=908&f=png&s=119056)\n\n所以**得出结论：file适用于比较小型的项目，规定几个特定的文件。**\n\n最后一个小细节，file里面只是入口文件，比如test里面依赖一个`rely.ts`那么在files中不写rely.ts也不会报错。在当前目录下运行一下tsc做比较就知道了~\n\n那文件很多的项目怎么办，下面的include和exclude就派上用场了\n\n## include && exclude\n\n当文件有很多的时候，就可以用include和exclude(当然也可以不用)结合使用，比如现在只想让src下的除了带except文件编译，如图所示：\n\n![3.png](https://user-gold-cdn.xitu.io/2020/2/1/16ffe7bf007a6b4c?w=1746&h=1050&f=png&s=120448)\n\n在该项目根目录输入tsc会发生什么呢？\n\n![4.png](https://user-gold-cdn.xitu.io/2020/2/1/16ffe7c637c8c2e6?w=812&h=938&f=png&s=66144)\n\n会发现并没有编译except.ts的文件\n\n### 注意\n\n当用webpack进行打包并暴露出bundle文件的时候会和tsconfig产生冲突，因为他俩都是编译/打包出来的文件，因此要在tsconfig.json中添加exclude到webpack打包出的指定路径，理解如图：\n\n![5.png](https://user-gold-cdn.xitu.io/2020/2/1/16ffe7caa92666fc?w=2708&h=1936&f=png&s=314209)\n\n把注释中的引开就解决这个问题了~\n\n### PS\n\n- include可以和file联用\n- exclude只对include有效，对files无效\n- 如果 files 和 include 都未设置，那么除了 exclude 排除的文件，编译器会默认包含路径下的所有 TS 文件\n\n# 几个常用的编译配置\n\n### allowJs\n\n允许编译js文件\n\n### sourceMap\n\n生成一个.map.js的文件，用于其他工具来debugg，类似于webpack的sourceMap\n\n### noImplicitAny\n\n不允许用any，如果初学ts，建议项目部太复杂的情况下，可以借此来进行限制，前置自己培养对ts的理解\n\n### module && target\n\n这两个有一定的关联关系\n\ntarget是编译成哪个版本的js(es3,es5,es6...)\n\nmodule模板生成的形式，默认情况下，当target是es3的时候，那module默认为commonjs形式，否则为es6形式。\n\n**注意(和outFile搭配使用)**：生成的模块形式：none、commonjs、amd、system、umd、es6、es2015 或 esnext 只有 amd 和 system 能和 outFile 一起使用 target 为 es5 或更低时可用 es6 和 es2015\n\n### lib\n\n引入ES的功能库，比如想在项目中用js中Set，Map等新的数据结构，或promise等，那要在lib中引入es2015\n\n### removeComments\n\n编译出的文件是否带注释，当为false的时候可以减少编译出文件的体积\n\n### allowSyntheticDefaultImports\n\n这个配置挺重要的，如果不知道会很纳闷，不好排查为啥会报错\n\n当它为false的时候,引入模块的时候必须以*as的形式，例如引入react\n\n`import * as React from 'react'`\n\n当为true的时候\n\n`import React from 'react'`\n但要注意，他要配合module是esModule的格式或者--esModuleInterop为true的时候，因为react是commonjs写的，并没有default,所以import React from 这种default引入是不对的，具体可以看下这篇文章 https://blog.leodots.me/post/40-think-about-allowSyntheticDefaultImports.html\n\n### jsx\n\n如果用tsx文件(React-ts)那么该项要配置成 jsx:\"react\"\n\n### baseUrl\n\n举个例子:\n\n在根目录的src目录有个hello文件夹，其中hello里包含world.ts\n\n在根目录的app.ts下\n\n`import { example } from \"./src/hello/world\"`\n\n当baseUrl: './src'\n\n则上面的目录可以简写成`import { example } from \"hello/world\"`\n\n### paths\n\npaths必须和上面的baseUrl联用，举个例子：\n\n![6.png](https://user-gold-cdn.xitu.io/2020/2/1/16ffe7d1a3071000?w=1050&h=1340&f=png&s=106459)\n那么将可以这样引入：\n\n![7.png](https://user-gold-cdn.xitu.io/2020/2/1/16ffe7d530e9d070?w=1864&h=970&f=png&s=174807)\n\n**但是有一点必须要特别注意：**\n\n如果用了webpack使用了alias,那么导致baseUrl不会生效，从而paths也不会生效，所以paths岂不是没用了吗？其实从实际作用来说确实是没用了，**不过可以将paths的配置和alias配置成一样的，在vscode中会有路径的自动提示，也是很方便很爽的**\n","time":"2020-02-01","title":"tsconfig.json入门指南"},{"articleId":"2019-02-20-竞态处理","content":"\n## 解决什么问题?\n当连续发送多个请求的时候，实际上想要的是最后一个请求的结果，但最后一个请求可能很快，但前面的请求很慢，这就导致了最后一个setState发生在了之前的请求里\n\n## 如何解决呢\n搜索了一阵，发现jquery里有对它的处理，但不可能引入个jquery的ajax吧，因此可以通过hooks来封装请求,还可复用，一举两得\n\n## code\n\n```\nfunction useRequest(reqFn: Promise<any>, rely: any[]) {\n  const [loading, setLoading] = useState(false);\n  const count = useRef(0);\n\n  useEffect(() => {\n    const curCount = count.current;\n    setLoading(true);\n    reqFn.then((res) => {\n      if (count.current !== curCount) {\n        return;\n      }\n      setLoading(false);\n      setUsername(res);\n    });\n    return () => {\n      // 防止warning \n      count.current += 1;\n    };\n  }, rely);\n}\n```\n\n### 为何要在卸载阶段 count.current += 1;\n经常会看到一种报错就是\n![warning.png](https://i.loli.net/2020/04/21/E8yMTDeZRwLxUpv.png)\n实际上造成的原因是由于组件已经卸载了，但是你的setState还没有完成，就会造成内存泄漏\n那上一步把count.current+1，如果请求回来之前切换了页面，却再也不会setState，因此也就解决了上面的问题\n","time":"2019-02-20","title":"竞态处理"}]